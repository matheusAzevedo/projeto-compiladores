	/*
  parser.cup

*/
import util.Log;
import main.Main;
import compiler.core.*;
import compiler.analysis.*;

parser code {:
	public static int errors = 0;
	
	public void report_error(String message, Object info){
   		StringBuffer m = new StringBuffer("Erro ");
		
		errors++;
   		
		if (info instanceof java_cup.runtime.Symbol){
     		m.append( "( "+ info.toString() + ")" );

   			m.append(" : " + message);
			System.err.println("Erro "+ Main.scanner.current_lexeme() + " : Erro sintï¿½tico");
   			System.err.println(m);
 		}
	}

 	public void report_fatal_error(String message, Object info) {
   		report_error(message, info);
   		throw new RuntimeException("Ocorreu um erro de sintaxe.");
 	}
:};

/* ------------ Declaracao dos temrinais e nao terminais ----------- */

/* ---- Palavras Reservadas ---- */
terminal ABSTRACT;
terminal BOOLEAN;
terminal BREAK;
terminal BYTE;
terminal CASE;
terminal CATCH;
terminal CHAR;
terminal CLASS;
terminal CONTINUE;
terminal DEFAULT;
terminal DOUBLE;
terminal DO;
terminal ELSE;
terminal EXTENDS;
terminal FINALLY;
terminal FINAL;
terminal FLOAT;
terminal FOR;
terminal IF;
terminal IMPLEMENTS;
terminal IMPORT;
terminal INSTANCEOF;
terminal INTERFACE;
terminal INT;
terminal LONG;
terminal NATIVE;
terminal NEW;
terminal NULL_LITERAL;
terminal PACKAGE;

terminal PRIVATE;
terminal PROTECTED;
terminal PUBLIC;

terminal RETURN;
terminal SHORT;
terminal STATIC;
terminal SUPER;
terminal SWITCH;
terminal SYNCHRONIZED;
terminal THIS;
terminal THREADSAFE;
terminal THROW;
terminal TRANSIENT;
terminal TRY;
terminal VOID;
terminal WHILE;

/* ---- Separadores ---- */
terminal LPAREN;
terminal RPAREN;
terminal LBRACE;
terminal RBRACE;
terminal LBRACK;
terminal RBRACK;
terminal SEMICOLON;
terminal COMMA;
terminal DOT;
/* ---- Atribuicao ---- */
terminal EQ;

/* ---- Operadores aritmeticos ---- */

terminal PLUS;
terminal MINUS;
terminal MULT;
terminal DIV;
terminal PLUSPLUS;
terminal PLUSEQ;
terminal MINUSEQ;
terminal MULTEQ;
terminal DIVEQ;
terminal MINUSMINUS;
terminal MOD;
terminal MODEQ;
terminal LSHIFT;
terminal RSHIFT;
terminal URSHIFT;
/* ---- Operadores ---- */
terminal COLON;
terminal COMP;
/* ---- Operadores Logicos ----  */
terminal EQEQ;
terminal GTEQ;
terminal LTEQ;
terminal LT;
terminal GT;
terminal OROR;
terminal OROREQ;
terminal ANDAND;
terminal AND;
terminal NOT;
terminal NOTEQ;
terminal OR;
terminal ANDEQ;
terminal OREQ;
terminal XOR;
terminal XOREQ;
terminal RSHIFTEQ;
terminal LSHIFTEQ;
terminal QUESTION;

/* ---- Tipos ---- */
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER; 
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;

non terminal compilation_unit;
non terminal type_specifier;
non terminal type;
non terminal identifier_opt;

non terminal expression;
non terminal expression_opt;
non terminal expression_loop;
non terminal expression_exp;
non terminal numeric_expression;
non terminal literal_expression;
non terminal string_expression;
non terminal bit_expression;
non terminal casting_expression;
non terminal testing_expression;
non terminal creating_expression;
non terminal creating_expression_termination;
non terminal creating_expression_opt;
non terminal logical_expression;
non terminal call_method;

non terminal pre_pos_op;
non terminal between_op;
non terminal string_op;
non terminal test_op;
non terminal bit_op;
non terminal logical_op;

non terminal brack;
non terminal brack_loop;

non terminal comma_opt;

non terminal termination_opt;

non terminal statement;
non terminal statement_block;
non terminal statement_loop;
non terminal do_statement;

non terminal modifier;
non terminal modifier_loop;

non terminal attribution;

non terminal package_declaration_opt;
non terminal package_statement;

non terminal import_statement_loop;
non terminal import_statement;
non terminal import_aux;

non terminal for_statement;
non terminal header_for;
non terminal init_test_upd;

non terminal while_statement;

non terminal if_statement;
non terminal else_opt;

non terminal switch_statement;
non terminal case_loop;
non terminal case_op;

non terminal type_declaration;
non terminal entity_name;

non terminal try_statement;
non terminal catch_op_loop;
non terminal finally_opt;

non terminal implements_declaration_opt;
non terminal implements_declaration_loop;
non terminal extends_declaration_opt;
non terminal class_declaration;
non terminal interface_declaration;
non terminal extends_interface_opt;

non terminal field_declaration;
non terminal field_declaration_loop;
non terminal constructor_declaration;
non terminal method_declaration;
non terminal declarations;
non terminal static_initializer;

non terminal variable_declaration;
non terminal variable_declarator;
non terminal variable_declarator_loop;
non terminal variable_initializer;
non terminal variable_initializer_opt;
non terminal variable_initializer_loop;
non terminal attr_opt;

non terminal parameter_list_opt;
non terminal parameter_list;
non terminal parameter;

non terminal arglist;

precedence left ELSE;
precedence right NOT;
precedence left COMP;
precedence left SEMICOLON;
precedence left FINALLY;
precedence left NEW;
precedence left OROREQ;
precedence left OROR;
precedence left CATCH;
precedence left INSTANCEOF;
precedence left DOT;
precedence left COMMA;
precedence left RPAREN;
precedence left RBRACE;
precedence left LBRACK,LPAREN;
precedence left MODEQ,MULTEQ,DIVEQ,MINUSEQ,PLUSEQ,MOD;
precedence left PLUS,MINUS;
precedence left MULT,DIV;
precedence left PLUSPLUS,MINUSMINUS;
precedence left RSHIFTEQ, URSHIFT, RSHIFT,LSHIFT;
precedence left EQEQ,NOTEQ;
precedence left GTEQ;
precedence left LTEQ;
precedence left GT;
precedence left LT;
precedence left DOT;
precedence left XOREQ,OREQ,ANDEQ,XOR,OR,AND,ANDAND,QUESTION;
precedence left TRANSIENT,THROW, THREADSAFE, THIS, SYNCHRONIZED, SUPER, STATIC,SHORT;
precedence left SHORT,RETURN, PUBLIC,PRIVATE, NATIVE,LONG, INT, FLOAT;
precedence left INTEGER_LITERAL;
precedence left FLOAT;
precedence left BOOLEAN_LITERAL;
precedence left STRING_LITERAL;
precedence left CHARACTER_LITERAL;
precedence left NULL_LITERAL;
precedence left IDENTIFIER;


start with compilation_unit;

compilation_unit ::= package_declaration_opt import_statement_loop type_declaration
	| package_declaration_opt type_declaration
;

package_statement ::= PACKAGE entity_name SEMICOLON;
package_declaration_opt ::= | package_statement;

import_statement_loop ::= import_statement 
	| import_statement import_statement_loop;
import_statement ::= IMPORT import_aux SEMICOLON;
import_aux ::= entity_name DOT MULT | entity_name;

type_declaration ::= class_declaration | interface_declaration;

class_declaration ::= modifier CLASS IDENTIFIER:id {:  
						Type type = new Type(id);
						SemanticsImpl.getInstance().addType(type);
					:} 
					extends_declaration_opt:superclass {:
						SemanticImpl.getInstance().addSupertype((String) id, (String) superclass);
					:} 
					implements_declaration_opt LBRACE field_declaration_loop RBRACE
;

extends_interface_opt ::= | EXTENDS implements_declaration_loop;

interface_declaration ::= modifier INTERFACE IDENTIFIER extends_interface_opt LBRACE field_declaration_loop RBRACE;

extends_declaration_opt ::= | EXTENDS entity_name:name {:RESULT = name;:};

modifier_loop ::= | modifier_loop modifier;

modifier ::=
    PUBLIC                                                                 
    | PRIVATE                                                               
    | PROTECTED                                                             
    | STATIC                                                                
    | FINAL                                                                 
    | NATIVE                                                                
    | SYNCHRONIZED                                                          
    | ABSTRACT                                                              
    | THREADSAFE                                                            
    | TRANSIENT                                                            
;

implements_declaration_loop ::= entity_name |
						entity_name COMMA implements_declaration_opt
;
implements_declaration_opt ::= | IMPLEMENTS implements_declaration_loop;

field_declaration_loop ::= | field_declaration_loop field_declaration;
field_declaration ::= 
	declarations
	| static_initializer
	| SEMICOLON
;
declarations ::= 
	method_declaration
	| constructor_declaration 
	| variable_declaration
;

method_declaration ::= modifier_loop type IDENTIFIER 
					LPAREN parameter_list_opt RPAREN termination_opt;

constructor_declaration ::= modifier_loop IDENTIFIER LPAREN parameter_list_opt RPAREN statement_block;

variable_declaration ::= modifier_loop type variable_declarator_loop SEMICOLON;

variable_declarator_loop ::= 
	variable_declarator 
	| variable_declarator_loop COMMA variable_declarator;

variable_declarator ::= IDENTIFIER brack_loop attr_opt;

attr_opt ::= 
	| EQ variable_initializer;

variable_initializer_opt ::=                             
    | variable_initializer_loop comma_opt
;

variable_initializer_loop ::=
    variable_initializer                                    
    | variable_initializer_loop COMMA variable_initializer
;

variable_initializer ::= 
	expression
	| LBRACE variable_initializer_opt RBRACE 

;

expression_exp ::=
	LPAREN arglist RPAREN
    | LBRACK expression RBRACK  
    | DOT expression  
    | COMMA expression  
    | INSTANCEOF entity_name
;

call_method ::= IDENTIFIER LPAREN arglist RPAREN;

numeric_expression ::= 
	MINUS expression 
	| pre_pos_op expression
	| expression pre_pos_op
	| expression between_op expression 
;

bit_expression ::= 
	COMP expression
	| expression bit_op expression;

testing_expression ::=
	expression test_op expression
;

logical_expression ::= 
	NOT expression
	| expression logical_op expression 
	| expression QUESTION expression COLON expression
	| BOOLEAN_LITERAL;

casting_expression ::= 
	LPAREN type RPAREN expression
;

creating_expression ::= NEW creating_expression_termination;

creating_expression_termination ::= 
	entity_name LPAREN arglist RPAREN
	| type_specifier creating_expression_opt brack_loop 
	| LPAREN expression RPAREN
;

creating_expression_opt ::= 
	| LPAREN expression RPAREN
;

bit_op ::= 
	RSHIFTEQ
	| LSHIFT
	| RSHIFT
	| URSHIFT
;

string_op ::= 
	PLUS
	| PLUSEQ
;

string_expression ::= 
	expression string_op expression
;

literal_expression ::= 
	INTEGER_LITERAL {::}
	| FLOATING_POINT_LITERAL {::}
	| BOOLEAN_LITERAL {::}
	| STRING_LITERAL {::}
	| CHARACTER_LITERAL {::}
	| NULL_LITERAL {::}
;

test_op ::= 
	LT
	| GT
	| LTEQ
	| GTEQ
	| EQEQ
	| NOTEQ;

between_op ::= 
	PLUS
	| PLUSEQ
	| MINUS
	| MINUSEQ
	| MULT
	| MULTEQ
	| DIV
	| DIVEQ
	| MOD
	| MODEQ;

pre_pos_op ::= 
	PLUSPLUS 
	| MINUSMINUS;

type_specifier ::= BOOLEAN {:RESULT = new Type("boolean");:}
	| BYTE {:RESULT = new Type("byte");:}		                                                            
    | CHAR {:RESULT = new Type("char");:}		                                                            
    | SHORT	{:RESULT = new Type("short");:}	                                                            
    | INT {:RESULT = new Type("int");:}		                                                            
    | FLOAT	{:RESULT = new Type("float");:}	                                                            
    | LONG	{:RESULT = new Type("long");:}	                                                            
    | DOUBLE {:RESULT = new Type("double");:}	                                                            
    | VOID {:RESULT = new Type("void");:}
    | entity_name:en {:
		Type type = new Type((String) en); 
		RESULT = type;
	:}
;

logical_op ::=
	AND
	| ANDEQ
	| OR
	| OROR
	| OREQ
	| XOR
	| XOREQ
	| ANDAND
	| OROREQ
	| MOD
	| MODEQ
;

entity_name ::=
	IDENTIFIER 
	| entity_name DOT IDENTIFIER
;

static_initializer ::= STATIC statement_block;

attribution ::= IDENTIFIER EQ expression;

comma_opt ::= | COMMA;

type ::= type_specifier brack_loop;

identifier_opt ::= | IDENTIFIER;

statement ::= 
	variable_declaration
	| expression SEMICOLON
	| statement_block
	| if_statement
	| do_statement
	| while_statement
	| for_statement
	| try_statement
	| switch_statement
	| SYNCHRONIZED LPAREN expression RPAREN statement
	| RETURN expression_opt SEMICOLON
	| THROW expression SEMICOLON
	| IDENTIFIER COLON statement
	| BREAK identifier_opt SEMICOLON
	| CONTINUE identifier_opt SEMICOLON 
	| SEMICOLON
;

try_statement ::= TRY statement catch_op_loop finally_opt; 

catch_op_loop ::= 
	| catch_op_loop CATCH LPAREN parameter RPAREN statement;

finally_opt ::= 
	| FINALLY statement
;

if_statement ::= 
	IF LPAREN expression RPAREN statement else_opt
;

else_opt ::= 
	| ELSE statement
;

while_statement ::=
    WHILE LPAREN expression RPAREN statement
;

switch_statement ::= 
	SWITCH LPAREN expression RPAREN LBRACE case_loop RBRACE;

case_loop ::= 
	| case_loop case_op
;

case_op ::= 
	CASE expression COLON
	| DEFAULT COLON
	| statement;

do_statement ::= 
	DO statement WHILE LPAREN expression RPAREN SEMICOLON
;

statement_block ::= LBRACE RBRACE | LBRACE statement_loop RBRACE;

statement_loop ::= statement | statement_loop statement;

for_statement ::= 
	header_for expression SEMICOLON expression SEMICOLON RPAREN statement 
	| header_for expression SEMICOLON RPAREN statement 
	| header_for SEMICOLON RPAREN statement 
	| header_for expression SEMICOLON expression RPAREN statement
;

header_for ::= 
	FOR LPAREN init_test_upd	
;

init_test_upd ::= 
	| variable_declaration
	| expression_opt SEMICOLON
	| SEMICOLON
;

expression_opt ::= 
	| expression;

termination_opt ::= statement_block | SEMICOLON;

parameter ::= type IDENTIFIER brack_loop;

parameter_list_opt ::= | parameter_list;

parameter_list ::= parameter | parameter_list COMMA parameter;

arglist ::= 
	| expression_loop
;

expression_loop ::=
    expression                                                            
    | expression_loop COMMA expression                                                                                            
;

expression ::= 
	numeric_expression
	| testing_expression
	| logical_expression
	| string_expression
	| bit_expression
	| casting_expression
	| creating_expression
	| literal_expression
	| NULL_LITERAL
	| SUPER
	| THIS
	| IDENTIFIER 
	| attribution
	| call_method
	| LPAREN expression RPAREN
	| expression expression_exp
;

brack ::= LBRACK RBRACK;

brack_loop ::= | brack brack_loop;